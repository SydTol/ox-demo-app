"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const solid_client_authn_core_1 = require("@inrupt/solid-client-authn-core");
const universal_fetch_1 = require("@inrupt/universal-fetch");
const oidc_client_ext_1 = require("@inrupt/oidc-client-ext");
const globalFetch = (request, init) => (0, universal_fetch_1.fetch)(request, init);
class ClientAuthentication {
    constructor(loginHandler, redirectHandler, logoutHandler, sessionInfoManager, issuerConfigFetcher) {
        this.loginHandler = loginHandler;
        this.redirectHandler = redirectHandler;
        this.logoutHandler = logoutHandler;
        this.sessionInfoManager = sessionInfoManager;
        this.issuerConfigFetcher = issuerConfigFetcher;
        this.login = async (options, eventEmitter) => {
            var _a, _b;
            await this.sessionInfoManager.clear(options.sessionId);
            const redirectUrl = (_a = options.redirectUrl) !== null && _a !== void 0 ? _a : (0, oidc_client_ext_1.removeOidcQueryParam)(window.location.href);
            if (!(0, solid_client_authn_core_1.isValidRedirectUrl)(redirectUrl)) {
                throw new Error(`${redirectUrl} is not a valid redirect URL, it is either a malformed IRI or it includes a hash fragment.`);
            }
            await this.loginHandler.handle({
                ...options,
                redirectUrl,
                clientName: (_b = options.clientName) !== null && _b !== void 0 ? _b : options.clientId,
                eventEmitter,
            });
        };
        this.fetch = globalFetch;
        this.logout = async (sessionId) => {
            await this.logoutHandler.handle(sessionId);
            this.fetch = globalFetch;
        };
        this.getSessionInfo = async (sessionId) => {
            return this.sessionInfoManager.get(sessionId);
        };
        this.getAllSessionInfo = async () => {
            return this.sessionInfoManager.getAll();
        };
        this.validateCurrentSession = async (currentSessionId) => {
            const sessionInfo = await this.sessionInfoManager.get(currentSessionId);
            if (sessionInfo === undefined ||
                sessionInfo.clientAppId === undefined ||
                sessionInfo.issuer === undefined) {
                return null;
            }
            return sessionInfo;
        };
        this.handleIncomingRedirect = async (url, eventEmitter) => {
            try {
                const redirectInfo = await this.redirectHandler.handle(url, eventEmitter);
                this.fetch = redirectInfo.fetch.bind(window);
                this.cleanUrlAfterRedirect(url);
                return {
                    isLoggedIn: redirectInfo.isLoggedIn,
                    webId: redirectInfo.webId,
                    sessionId: redirectInfo.sessionId,
                    expirationDate: redirectInfo.expirationDate,
                };
            }
            catch (err) {
                this.cleanUrlAfterRedirect(url);
                eventEmitter.emit(solid_client_authn_core_1.EVENTS.ERROR, "redirect", err);
                return undefined;
            }
        };
    }
    cleanUrlAfterRedirect(url) {
        const cleanedUpUrl = new URL(url);
        cleanedUpUrl.searchParams.delete("state");
        cleanedUpUrl.searchParams.delete("code");
        cleanedUpUrl.searchParams.delete("id_token");
        cleanedUpUrl.searchParams.delete("access_token");
        cleanedUpUrl.searchParams.delete("error");
        cleanedUpUrl.searchParams.delete("error_description");
        cleanedUpUrl.searchParams.delete("iss");
        window.history.replaceState(null, "", cleanedUpUrl.toString());
    }
}
exports.default = ClientAuthentication;
//# sourceMappingURL=ClientAuthentication.js.map